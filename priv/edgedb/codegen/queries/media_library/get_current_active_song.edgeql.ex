# AUTOGENERATED: DO NOT MODIFY
# Generated by Elixir client for EdgeDB via `mix edgedb.generate` from
#   `priv/edgedb/edgeql/media_library/get_current_active_song.edgeql`.
defmodule Tests.Codegen.Queries.MediaLibrary.GetCurrentActiveSong do
  @query """
  select Song {
    *,
    mp3: {
      *
    },
    user: {
      id,
    }
  }
  filter
    .user.id = <uuid>$user_id
      and
    .status in {SongStatus.playing, SongStatus.paused}
  limit 1
  """

  @moduledoc """
  Generated module for the EdgeQL query from
    `priv/edgedb/edgeql/media_library/get_current_active_song.edgeql`.

  Query:

  ```edgeql
  #{@query}
  ```
  """

  @typedoc """
  ```edgeql
  std::uuid
  ```
  """
  @type uuid() :: binary()

  @typedoc """
  ```edgeql
  std::duration
  ```
  """
  @type duration() :: Timex.Duration.t() | integer()

  @typedoc """
  ```edgeql
  scalar type default::SongStatus extending enum<stopped, playing, paused>
  ```
  """
  @type default__song_status() :: String.t() | :stopped | :playing | :paused

  @typedoc """
  ```edgeql
  scalar type default::inet extending std::bytes
  ```
  """
  @type default__inet() :: bitstring()

  defmodule Result do
    defmodule Mp3 do
      defstruct [:id, :filename, :filepath, :filesize, :url]

      @type t() :: %__MODULE__{
              id: uuid(),
              filename: String.t(),
              filepath: String.t(),
              filesize: EdgeDB.ConfigMemory.t(),
              url: String.t()
            }
    end

    defmodule User do
      defstruct [:id]
      @type t() :: %__MODULE__{id: uuid()} | nil
    end

    defstruct [
      :mp3,
      :user,
      :artist,
      :title,
      :attribution,
      :date_recorded,
      :date_released,
      :paused_at,
      :played_at,
      :server_ip,
      :position,
      :id,
      :inserted_at,
      :updated_at,
      :status,
      :duration
    ]

    @type t() ::
            %__MODULE__{
              mp3: Mp3.t(),
              user: User.t() | nil,
              artist: String.t(),
              title: String.t(),
              attribution: String.t() | nil,
              date_recorded: NaiveDateTime.t() | nil,
              date_released: NaiveDateTime.t() | nil,
              paused_at: DateTime.t() | nil,
              played_at: DateTime.t() | nil,
              server_ip: default__inet() | nil,
              position: integer(),
              id: uuid(),
              inserted_at: NaiveDateTime.t(),
              updated_at: NaiveDateTime.t(),
              status: default__song_status(),
              duration: duration()
            }
            | nil
  end

  @type keyword_args() :: [{:user_id, uuid()}]

  @type map_args() :: %{
          user_id: uuid()
        }

  @type args() :: map_args() | keyword_args()

  @doc """
  Run the query.
  """
  @spec query(
          client :: EdgeDB.client(),
          args :: args(),
          opts :: list(EdgeDB.query_option())
        ) ::
          {:ok, Result.t()}
          | {:error, reason}
        when reason: any()
  def query(client, args, opts \\ []) do
    do_query(client, args, opts)
  end

  @doc """
  Run the query.
  """
  @spec query!(
          client :: EdgeDB.client(),
          args :: args(),
          opts :: list(EdgeDB.query_option())
        ) :: Result.t()
  def query!(client, args, opts \\ []) do
    case do_query(client, args, opts) do
      {:ok, result} ->
        result

      {:error, exc} ->
        raise exc
    end
  end

  defp do_query(client, args, opts) do
    EdgeDB.query_single(client, @query, args, opts)

    shape = %Result{
      updated_at: result["updated_at"],
      title: result["title"],
      status: result["status"],
      server_ip: result["server_ip"],
      position: result["position"],
      played_at: result["played_at"],
      paused_at: result["paused_at"],
      inserted_at: result["inserted_at"],
      id: result["id"],
      duration: result["duration"],
      date_released: result["date_released"],
      date_recorded: result["date_recorded"],
      attribution: result["attribution"],
      artist: result["artist"],
      user: %Result.User{id: result["user"]["id"]},
      mp3: %Result.Mp3{
        url: result["mp3"]["url"],
        id: result["mp3"]["id"],
        filesize: result["mp3"]["filesize"],
        filepath: result["mp3"]["filepath"],
        filename: result["mp3"]["filename"]
      }
    }
  end
end
